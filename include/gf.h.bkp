#pragma once

#include <iostream>
#include <vector>

using extent_range = boost::multi_array_types::extent_range;
using extent_gen = boost::multi_array_types::extent_gen;

extent_range ffreq( int n )
{
   return extent_range( -n, n );   // range [ -n , n )
}

extent_range bfreq( int n )
{
   return extent_range( -n, n + 1 );   // range [ -n , n + 1 )
}

   template <class T, std::size_t N>
std::ostream& operator<<( std::ostream& os, const std::array<T, N>& arr )
{
   std::copy(arr.cbegin(), arr.cend(), std::ostream_iterator<T>(os, " "));
   return os;
}
/********************* Index type ********************/

template< unsigned int ndims_ >
class idx_obj_t							///< Index type that will be associated to each container
{
   public:
      static constexpr unsigned int ndims = ndims_; 				///< The number of dimensions

      using arr_t = std::array<int, ndims>; 	///< Array type

      arr_t idx_arr; 				///< Data array

      template< typename integer_t >
      int& operator()( integer_t val )		///< Accesss by name, e.g. idx(name_t::w)
      {
	 return idx_arr[int(val)]; 
      }

      inline int* data()				///< Pointer to first data element
      {
	 return idx_arr.data(); 
      }

      idx_obj_t( const arr_t& idx_arr_ ):
	 idx_arr( idx_arr_ )	 
   {}

      idx_obj_t( arr_t&& idx_arr_ ):
	 idx_arr( idx_arr_ )	 
   {}

      friend std::ostream& operator<<( std::ostream& os, idx_obj_t idx )	///< Output idx_t object to ostream
      {
	 return os << idx.idx_arr;
      }

}; 

/********************* Container ********************/

template< typename value_t_, unsigned int ndims_>
class gf: public boost::multi_array<value_t_, ndims_>
{
   public:

      // -------  Typedefs
      using value_t = value_t_; 						///< Type of container values
      using base_t = boost::multi_array<value_t, ndims_>; 			///< Type of base class
      using extents_t = boost::detail::multi_array::extent_gen<ndims_>; 	///< Type of extents object passed at contruction
      using idx_t = idx_obj_t<ndims_>; 

      // -------- Member variables
      const typename base_t::size_type* shape_arr; 				///< Array containing the extent for each dimension
      const typename base_t::index* idx_bases; 				///< Array containing the base index for each dimension
      static constexpr unsigned int ndims = ndims_; 				///< The number of dimensions



      inline int get_pos_1d( idx_t& idx )				///< For a given idx_t object, returns the corresponding position in a 1d array
      {
	 return get_pos_1d( idx.idx_arr ); 
      }

      int get_pos_1d( const std::array<int, ndims>& idx_arr )			///< For a given index array, returns the corresponding position in a 1d array
      {
	 int val = idx_arr[0] - idx_bases[0]; 
	 for( int i = 1; i < ndims; ++i )
	 {
	    val += shape_arr[i-1] * val + ( idx_arr[i] - idx_bases[i] ); 
	 }
	 return val; 
      }

      idx_t get_idx( int pos_1d )					///< For a given index in a 1d array, returns the corresponding idx_t object
      {
	 assert( pos_1d < base_t::num_elements() ); 
	 std::array<int, ndims> idx_arr; 

	 idx_arr[ndims-1] = idx_bases[ndims-1] + pos_1d % shape_arr[ndims-1];

	 for( int i = ndims - 2; i >= 0; --i )
	 {
	    pos_1d = ( pos_1d - ( idx_arr[i+1] - idx_bases[i+1] ) ) / shape_arr[i]; 
	    idx_arr[i] = idx_bases[i] + pos_1d % shape_arr[i];
	 }

	 return idx_t( idx_arr ); 
      }

      void fill_idx_lst( std::vector<idx_t>& idx_lst )			///< Fills a std::vector<idx_t> with all possible sets of indeces
      {
	 for( int i = 0; i < base_t::num_elements(); ++i )
	    idx_lst.push_back( get_idx( i ) ); 
      }

      typedef value_t (*init_func_t)( idx_t& idx ); 			///< Initalization function type that returns value_t for a given idx_t object

      void init( init_func_t init_func )				///< Initializes values with a given initialization function
      {
	 for( int i = 0; i < base_t::num_elements(); ++i )
	 {
	    idx_t idx( get_idx( i ) ) ; 
	    operator()( idx ) = init_func( idx ); 
	 }
      }
	    
      value_t& operator()( const idx_t& idx )					///< Return value of container for given index object
      {
	 return data[ get_pos_1d( idx.idx_arr ) ]; 
      }

      value_t& operator()( int i )					///< Return value of container for given index object
      {
	 return data[ i ]; 
      }

      gf( extents_t idx_ranges ):
	 base_t( idx_ranges ), shape_arr( base_t::shape() ), idx_bases( base_t::index_bases() ), data( base_t::data() ) 
   {};


   private:
      value_t* data; 

};

